<!-- 
Coding Credits:

For the purposes of acknowledgement, this HTML structure was inspired by the following tutorial:
https://youtu.be/Z1RJmh_OqeA
-->

{% extends "base.html" %}
{% block title %}Edit Form{% endblock %}

{% block content %}

<h1>Edit Form</h1>

<h2>{{ form.title }}</h2>
<p>{{ form.description }}</p>
<p>Current version: {{ form_version.version_number }}</p>

<style>
  .branchWrap { margin-top:10px; padding:10px; border:1px solid #ddd; }
  .branchRow { display:flex; gap:10px; align-items:center; margin-top:8px; }
  .qmetaLine { display:flex; gap:8px; align-items:center; margin:6px 0 10px 0; font-size:13px; }
  .badge { display:inline-flex; align-items:center; padding:2px 8px; border:1px solid #ddd; background:#fff; }
  .badgeStrong { font-weight:700; }
</style>

<form method="POST" id="editForm">

  <h3>Existing questions</h3>
  <p>Use ^ and v to change order. Edit fields to reword. Tick Delete to remove from the next version.</p>

  <div id="existingList">
    {% for q in questions %}
      <div class="qrow">
        <div>
          <button type="button" onclick="moveUp(this)">^</button>
          <button type="button" onclick="moveDown(this)">v</button>
        </div>

        <div>
          <input type="hidden" name="existing_qv_id" value="{{ q.question_version_id }}">

          <div class="qmetaLine">
            <span class="badge badgeStrong qNum"></span>
            <span class="badge qType" id="typeBadge_{{ q.question_version_id }}"></span>
            <span class="badge qBranch" id="branchBadge_{{ q.question_version_id }}"></span>
          </div>

          <div>
            <label>Prompt</label><br>
            <input type="text" name="existing_prompt_{{ q.question_version_id }}" value="{{ q.prompt_text }}" required>
          </div>

          <div>
            <label>Type</label><br>
            <select name="existing_type_{{ q.question_version_id }}" onchange="toggleExistingOptions(this)" data-qvid="{{ q.question_version_id }}">
              <option value="text" {% if q.response_type == "text" %}selected{% endif %}>text</option>
              <option value="number" {% if q.response_type == "number" %}selected{% endif %}>number</option>
              <option value="rating" {% if q.response_type == "rating" %}selected{% endif %}>rating</option>
              <option value="select" {% if q.response_type == "select" %}selected{% endif %}>select</option>
            </select>
          </div>

          <div>
            <label>Required</label><br>
            <select name="existing_required_{{ q.question_version_id }}">
              <option value="0" {% if not q.is_required %}selected{% endif %}>No</option>
              <option value="1" {% if q.is_required %}selected{% endif %}>Yes</option>
            </select>
          </div>

          <div>
            <label>Help text (optional)</label><br>
            <input type="text" name="existing_help_{{ q.question_version_id }}" value="{{ q.help_text or '' }}">
          </div>

          <div class="existingOptionsBlock" id="existingOptions_{{ q.question_version_id }}" {% if q.response_type != "select" %}style="display:none;"{% endif %}>
            <label>Options (one per line)</label><br>
            <textarea name="existing_options_{{ q.question_version_id }}" rows="5">{% if q.response_type == "select" %}{% for opt in q.options %}{{ opt.option_label }}{% if not loop.last %}{{ "\n" }}{% endif %}{% endfor %}{% endif %}</textarea>
          </div>

          <div id="branchWrap_{{ q.question_version_id }}" class="branchWrap" {% if q.response_type != "select" %}style="display:none;"{% endif %}>
            <label>
              <input type="checkbox" class="branchToggle" data-qvid="{{ q.question_version_id }}" {% if branch_maps and (q.question_version_id in branch_maps) %}checked{% endif %}>
              Branching
            </label>
            <input type="hidden" name="branch_state_source" value="{{ q.question_version_id }}">
            <input type="hidden" name="branch_state_enabled" value="{% if branch_maps and (q.question_version_id in branch_maps) %}1{% else %}0{% endif %}" class="branchState" data-qvid="{{ q.question_version_id }}">
            <div class="branchPanel" id="branchPanel_{{ q.question_version_id }}" data-branch='{{ (branch_maps.get(q.question_version_id) or {})|tojson }}' style="display:{% if branch_maps and (q.question_version_id in branch_maps) %}block{% else %}none{% endif %};"></div>
          </div>

          <textarea name="existing_options_{{ q.question_version_id }}" class="existingOptionsHidden" id="existingOptionsHidden_{{ q.question_version_id }}" style="display:none;" rows="1" {% if q.response_type == "select" %}disabled{% endif %}></textarea>
        </div>

        <label>
          <input type="checkbox" name="delete_qv_id" value="{{ q.question_version_id }}">
          Delete
        </label>
      </div>
    {% endfor %}
  </div>

  <h3>Add new questions</h3>

  <div id="newQuestions"></div>

  <button type="button" onclick="addNewQuestion()">+ Add Question</button>

  <div style="margin-top:14px;">
    <button type="submit">Save as New Version</button>
    <a href="{{ url_for('form') }}">Cancel</a>
  </div>

</form>

<script>
  function safeParseJson(s) {
    try {
      return JSON.parse(s);
    } catch (e) {
      return null;
    }
  }

  function typeLabel(v) {
    const map = { text: "Text", number: "Number", rating: "Rating", select: "Select", multi_select: "Multi-select" };
    return map[v] || v || "";
  }

  function updateBranchBadge(qvid) {
    const badge = document.getElementById("branchBadge_" + qvid);
    if (!badge) return;

    const wrap = document.getElementById("branchWrap_" + qvid);
    const toggle = wrap ? wrap.querySelector(".branchToggle") : null;
    const panel = document.getElementById("branchPanel_" + qvid);
    const typeSel = document.querySelector(`select[name="existing_type_${qvid}"]`);

    if (!typeSel || typeSel.value !== "select") {
      badge.textContent = "No branching";
      return;
    }

    if (!toggle || !toggle.checked || !panel) {
      badge.textContent = "No branching";
      return;
    }

    const rows = Array.from(panel.querySelectorAll('.branchRow'));
    const active = rows.filter(r => {
      const tgt = r.querySelector('select[name="branch_map_target"]');
      return tgt && String(tgt.value || '').trim() !== '';
    });

    badge.textContent = active.length ? `Branching: ${active.length} path(s)` : "Branching on";
  }

  function refreshMeta() {
    const list = document.getElementById("existingList");
    if (!list) return;
    const rows = Array.from(list.querySelectorAll(".qrow"));
    rows.forEach((row, idx) => {
      const qvidEl = row.querySelector('input[name="existing_qv_id"]');
      if (!qvidEl) return;
      const qvid = String(qvidEl.value || "").trim();
      const numEl = row.querySelector(".qNum");
      if (numEl) numEl.textContent = `Q${idx + 1}`;
      const typeSel = row.querySelector(`select[name="existing_type_${qvid}"]`);
      const typeBadge = document.getElementById("typeBadge_" + qvid);
      if (typeBadge && typeSel) typeBadge.textContent = typeLabel(typeSel.value);
      updateBranchBadge(qvid);
    });
  }

  function moveUp(btn) {
    const row = btn.closest(".qrow");
    const list = document.getElementById("existingList");
    const rows = Array.from(list.querySelectorAll(".qrow"));
    const idx = rows.indexOf(row);
    if (idx > 0) {
      list.insertBefore(row, rows[idx - 1]);
    }
    document.querySelectorAll(".branchToggle").forEach(t => { if (t.checked) rebuildBranchPanel(t.getAttribute("data-qvid")); });
    refreshMeta();
  }

  function moveDown(btn) {
    const row = btn.closest(".qrow");
    const list = document.getElementById("existingList");
    const rows = Array.from(list.querySelectorAll(".qrow"));
    const idx = rows.indexOf(row);
    if (idx >= 0 && idx < rows.length - 1) {
      list.insertBefore(rows[idx + 1], row);
    }
    document.querySelectorAll(".branchToggle").forEach(t => { if (t.checked) rebuildBranchPanel(t.getAttribute("data-qvid")); });
    refreshMeta();
  }

  function toggleExistingOptions(sel) {
    const qvid = sel.getAttribute("data-qvid");
    const block = document.getElementById("existingOptions_" + qvid);
    const hidden = document.getElementById("existingOptionsHidden_" + qvid);
    const branchWrap = document.getElementById("branchWrap_" + qvid);
    const branchPanel = document.getElementById("branchPanel_" + qvid);
    const branchToggle = branchWrap ? branchWrap.querySelector(".branchToggle") : null;
    const stateEl = document.querySelector(`input.branchState[data-qvid="${qvid}"]`);
    const ta = block ? block.querySelector("textarea") : null;

    if (sel.value === "select") {
      if (block) block.style.display = "block";
      if (ta) ta.disabled = false;
      if (hidden) hidden.disabled = true;
      if (branchWrap) branchWrap.style.display = "block";
    } else {
      if (stateEl) stateEl.value = "0";
      if (block) block.style.display = "none";
      if (ta) {
        ta.disabled = true;
        ta.value = "";
      }
      if (hidden) hidden.disabled = false;
      if (branchToggle) branchToggle.checked = false;
      if (branchPanel) branchPanel.style.display = "none";
      if (branchWrap) branchWrap.style.display = "none";
      if (branchPanel) branchPanel.innerHTML = "";
    }
    refreshMeta();
  }

  function getExistingRowsInOrder() {
    const list = document.getElementById("existingList");
    if (!list) return [];
    const rows = Array.from(list.querySelectorAll(".qrow"));
    return rows;
  }

  function getQuestionTargets(currentQvid) {
    const rows = getExistingRowsInOrder();
    const targets = [];
    rows.forEach((row, idx) => {
      const hidden = row.querySelector('input[name="existing_qv_id"]');
      if (!hidden) return;
      const qvid = String(hidden.value || "").trim();
      if (!qvid) return;
      if (qvid === String(currentQvid)) return;
      const del = row.querySelector('input[type="checkbox"][name="delete_qv_id"]');
      if (del && del.checked) return;
      const prompt = row.querySelector(`input[name="existing_prompt_${qvid}"]`);
      const label = prompt ? (prompt.value || "").trim() : "";
      targets.push({ value: qvid, text: `Q${idx + 1}: ${label || "Untitled"}` });
    });
    return targets;
  }

  function getOptionLinesForQvid(qvid) {
    const block = document.getElementById("existingOptions_" + qvid);
    const ta = block ? block.querySelector("textarea") : null;
    const lines = [];
    if (!ta) return lines;
    (ta.value || "").split(/\r?\n/).forEach(l => {
      const t = String(l || "").trim();
      if (t) lines.push(t);
    });
    return lines;
  }

  function rebuildBranchPanel(qvid) {
    const panel = document.getElementById("branchPanel_" + qvid);
    if (!panel) return;

    const targets = getQuestionTargets(qvid);
    const options = getOptionLinesForQvid(qvid);

    if (options.length === 0) {
      panel.innerHTML = "";
      updateBranchBadge(qvid);
      return;
    }

    const saved = safeParseJson(panel.getAttribute("data-branch") || "");
    const map = (saved && typeof saved === "object" && !Array.isArray(saved)) ? saved : {};

    const tgtOpts = [`<option value="">(no question)</option>`].concat(
      targets.map(t => `<option value="${t.value}">${t.text.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</option>`)
    ).join("");

    const rows = options.map(opt => {
      const safeOpt = String(opt).replace(/</g, "&lt;").replace(/>/g, "&gt;");
      const valOpt = String(opt).replace(/"/g, "&quot;");
      const selectedTarget = map[opt] ? String(map[opt]) : "";
      return `
        <div class="branchRow">
          <div style="min-width:160px;">When <strong>${safeOpt}</strong> is selected</div>
          <input type="hidden" name="branch_map_source" value="${qvid}">
          <input type="hidden" name="branch_map_option" value="${valOpt}">
          <select name="branch_map_target" class="branchMapTarget">${tgtOpts}</select>
        </div>
      `;
    }).join("");

    panel.innerHTML = rows;

    const selects = panel.querySelectorAll("select.branchMapTarget");
    selects.forEach((sel, idx) => {
      const opt = options[idx];
      const t = map[opt] ? String(map[opt]) : "";
      sel.value = t;
      sel.addEventListener("change", function() { updateBranchBadge(qvid); });
    });

    updateBranchBadge(qvid);
  }

  function onBranchToggleChanged(toggleEl) {
    const qvid = toggleEl.getAttribute("data-qvid");
    const panel = document.getElementById("branchPanel_" + qvid);
    if (!panel) return;

    const stateEl = document.querySelector(`input.branchState[data-qvid="${qvid}"]`);

    if (toggleEl.checked) {
      if (stateEl) stateEl.value = "1";
      rebuildBranchPanel(qvid);
      panel.style.display = "block";
    } else {
      if (stateEl) stateEl.value = "0";
      panel.style.display = "none";
      panel.innerHTML = "";
    }
    updateBranchBadge(qvid);
  }
  (function initExistingOptionBlocks() {
    const selects = document.querySelectorAll("select[data-qvid]");
    selects.forEach(s => toggleExistingOptions(s));

    const toggles = document.querySelectorAll(".branchToggle");
    toggles.forEach(t => {
      t.addEventListener("change", function() { onBranchToggleChanged(t); });
    });

    toggles.forEach(t => {
      if (t.checked) {
        const qvid = t.getAttribute("data-qvid");
        rebuildBranchPanel(qvid);
      }
    });

    const list = document.getElementById("existingList");
    if (list) {
      list.addEventListener("input", function(e) {
        const ta = e.target;
        if (ta && ta.tagName === "TEXTAREA" && ta.name && ta.name.startsWith("existing_options_")) {
          const qvid = ta.name.replace("existing_options_", "");
          const wrap = document.getElementById("branchWrap_" + qvid);
          const toggle = wrap ? wrap.querySelector(".branchToggle") : null;
          if (toggle && toggle.checked) rebuildBranchPanel(qvid);
        }
        const inp = e.target;
        if (inp && inp.tagName === "INPUT" && inp.name && inp.name.startsWith("existing_prompt_")) {
          document.querySelectorAll(".branchToggle").forEach(t => {
            if (t.checked) {
              const qvid = t.getAttribute("data-qvid");
              rebuildBranchPanel(qvid);
            }
          });
        }

        if (inp && inp.tagName === "INPUT" && inp.name && inp.name.startsWith("existing_prompt_")) {
          refreshMeta();
        }

        if (e.target && e.target.tagName === "SELECT" && e.target.name && e.target.name.startsWith("existing_type_")) {
          refreshMeta();
        }
      });
    }

    refreshMeta();
  })();
</script>

{% endblock %}